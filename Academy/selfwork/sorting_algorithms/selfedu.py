#-------------------------------------------------
# Алгоритм сортировки выбором
#-------------------------------------------------

def selection_sort(a):

    N = len(a)      # число элементов в списке

    for i in range(N-1):
        m = a[i]            # запоминаем минимальное значение
        p = i               # запоминаем индекс минимального значения
        for j in range(i+1, N):  # поиск миимального среди оставшихся элементов
            if m > a[j]:
                m = a[j]
                p = j

        if p != i:          # обмен значениями, если был найден минимальный не в i-й позиции
            t = a[i]
            a[i] = a[p]
            a[p] = t

    return a

#-------------------------------------------------
# Алгоритм сортировки пузырьком
#-------------------------------------------------

def bubble_sort(a):

    N = len(a)      # число элементов в списке

    for i in range(N-1):     # N-1 итераций работы алгоритма
        for j in range(N-1-i):   # проход по оставшимся не отсортированным парам массива
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]

    return a

#-------------------------------------------------
# Алгоритм сортировки вставками
#-------------------------------------------------

def insertion_sort(a):

    N = len(a)      # число элементов в списке

    for i in range(1, N):
        for j in range(i, 0, -1):
            if a[j] < a[j-1]:
                a[j], a[j-1] = a[j-1], a[j]
            else:
                break

    return a

#-------------------------------------------------
# Сортировка слиянием
#-------------------------------------------------

# функция слияния двух отсортированных списков
def merge_list(a, b):
    c = []
    N = len(a)
    M = len(b)

    i = 0
    j = 0
    while i < N and j < M:
        if a[i] <= b[j]:
            c.append(a[i])
            i += 1
        else:
            c.append(b[j])
            j += 1

    c += a[i:] + b[j:]
    return c

# функция деления списка и слияния списков в общий отсортированный список
def merge_sort(a):
    N1 = len(a) // 2
    a1 = a[:N1]     # деление массива на два примерно равной длины
    a2 = a[N1:]

    if len(a1) > 1: # если длина 1-го списка больше 1, то делим дальше
        a1 = merge_sort(a1)
    if len(a2) > 1: # если длина 2-го списка больше 1, то делим дальше
        a2 = merge_sort(a2)

    return merge_list(a1, a2)   # слияние двух отсортированных списков в один

#-------------------------------------------------
# Быстрая сортировка Хоара через рекурсию
#-------------------------------------------------

def quick_sort(a):

    import random

    if len(a) > 1:
        x = a[random.randint(0, len(a)-1)]      # случайное пороговое значение (для разделения на малые и большие)
        low = [u for u in a if u < x]
        eq = [u for u in a if u == x]
        hi = [u for u in a if u > x]
        a = quick_sort(low) + eq + quick_sort(hi)

    return a


if __name__ == "__main__":
    import random
    test_list = [random.randint(1, 100) for _ in range(23)]
    for func in (bubble_sort, selection_sort, insertion_sort, merge_sort, quick_sort):
        print(func(test_list))
